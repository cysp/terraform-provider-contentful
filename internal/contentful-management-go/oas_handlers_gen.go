// Code generated by ogen, DO NOT EDIT.

package contentfulmanagement

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

type codeRecorder struct {
	http.ResponseWriter
	status int
}

func (c *codeRecorder) WriteHeader(status int) {
	c.status = status
	c.ResponseWriter.WriteHeader(status)
}

func recordError(string, error) {}

// handleActivateContentTypeRequest handles activateContentType operation.
//
// Activate a content type.
//
// PUT /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}/published
func (s *Server) handleActivateContentTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivateContentTypeOperation,
			ID:   "activateContentType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, ActivateContentTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeActivateContentTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivateContentTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivateContentTypeOperation,
			OperationSummary: "Activate a content type",
			OperationID:      "activateContentType",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivateContentTypeParams
			Response = ActivateContentTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivateContentTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivateContentType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivateContentType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivateContentTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateAppDefinitionRequest handles createAppDefinition operation.
//
// Create an app definition.
//
// POST /organizations/{organization_id}/app_definitions
func (s *Server) handleCreateAppDefinitionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateAppDefinitionOperation,
			ID:   "createAppDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, CreateAppDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCreateAppDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCreateAppDefinitionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateAppDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateAppDefinitionOperation,
			OperationSummary: "Create an app definition",
			OperationID:      "createAppDefinition",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
			},
			Raw: r,
		}

		type (
			Request  = *AppDefinitionFields
			Params   = CreateAppDefinitionParams
			Response = CreateAppDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCreateAppDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateAppDefinition(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateAppDefinition(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateAppDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateDeliveryApiKeyRequest handles createDeliveryApiKey operation.
//
// Create a delivery api key.
//
// POST /spaces/{space_id}/api_keys
func (s *Server) handleCreateDeliveryApiKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateDeliveryApiKeyOperation,
			ID:   "createDeliveryApiKey",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, CreateDeliveryApiKeyOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCreateDeliveryApiKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCreateDeliveryApiKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateDeliveryApiKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateDeliveryApiKeyOperation,
			OperationSummary: "Create a delivery api key",
			OperationID:      "createDeliveryApiKey",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
			},
			Raw: r,
		}

		type (
			Request  = *ApiKeyRequestFields
			Params   = CreateDeliveryApiKeyParams
			Response = CreateDeliveryApiKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCreateDeliveryApiKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateDeliveryApiKey(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateDeliveryApiKey(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateDeliveryApiKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreatePersonalAccessTokenRequest handles createPersonalAccessToken operation.
//
// Create a personal access token.
//
// POST /users/me/access_tokens
func (s *Server) handleCreatePersonalAccessTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreatePersonalAccessTokenOperation,
			ID:   "createPersonalAccessToken",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, CreatePersonalAccessTokenOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCreatePersonalAccessTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreatePersonalAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreatePersonalAccessTokenOperation,
			OperationSummary: "Create a personal access token",
			OperationID:      "createPersonalAccessToken",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *PersonalAccessTokenRequestFields
			Params   = struct{}
			Response = CreatePersonalAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreatePersonalAccessToken(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreatePersonalAccessToken(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreatePersonalAccessTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateRoleRequest handles createRole operation.
//
// Create a role.
//
// POST /spaces/{space_id}/roles
func (s *Server) handleCreateRoleRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateRoleOperation,
			ID:   "createRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, CreateRoleOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCreateRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCreateRoleRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateRoleOperation,
			OperationSummary: "Create a role",
			OperationID:      "createRole",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
			},
			Raw: r,
		}

		type (
			Request  = *RoleFields
			Params   = CreateRoleParams
			Response = CreateRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCreateRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateRole(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateRole(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateRoleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateWebhookDefinitionRequest handles createWebhookDefinition operation.
//
// Create a webhook definition.
//
// POST /spaces/{space_id}/webhook_definitions
func (s *Server) handleCreateWebhookDefinitionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateWebhookDefinitionOperation,
			ID:   "createWebhookDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, CreateWebhookDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCreateWebhookDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCreateWebhookDefinitionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateWebhookDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateWebhookDefinitionOperation,
			OperationSummary: "Create a webhook definition",
			OperationID:      "createWebhookDefinition",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
			},
			Raw: r,
		}

		type (
			Request  = *WebhookDefinitionFields
			Params   = CreateWebhookDefinitionParams
			Response = CreateWebhookDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCreateWebhookDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateWebhookDefinition(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateWebhookDefinition(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateWebhookDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeactivateContentTypeRequest handles deactivateContentType operation.
//
// Deactivate a content type.
//
// DELETE /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}/published
func (s *Server) handleDeactivateContentTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeactivateContentTypeOperation,
			ID:   "deactivateContentType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeactivateContentTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeactivateContentTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeactivateContentTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeactivateContentTypeOperation,
			OperationSummary: "Deactivate a content type",
			OperationID:      "deactivateContentType",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeactivateContentTypeParams
			Response = DeactivateContentTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeactivateContentTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeactivateContentType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeactivateContentType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeactivateContentTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteAppDefinitionRequest handles deleteAppDefinition operation.
//
// Delete an app definition.
//
// DELETE /organizations/{organization_id}/app_definitions/{app_definition_id}
func (s *Server) handleDeleteAppDefinitionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteAppDefinitionOperation,
			ID:   "deleteAppDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteAppDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteAppDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteAppDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteAppDefinitionOperation,
			OperationSummary: "Delete an app definition",
			OperationID:      "deleteAppDefinition",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteAppDefinitionParams
			Response = DeleteAppDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteAppDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteAppDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteAppDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteAppDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteAppInstallationRequest handles deleteAppInstallation operation.
//
// Uninstall an app.
//
// DELETE /spaces/{space_id}/environments/{environment_id}/app_installations/{app_definition_id}
func (s *Server) handleDeleteAppInstallationRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteAppInstallationOperation,
			ID:   "deleteAppInstallation",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteAppInstallationOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteAppInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteAppInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteAppInstallationOperation,
			OperationSummary: "Uninstall an app",
			OperationID:      "deleteAppInstallation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteAppInstallationParams
			Response = DeleteAppInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteAppInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteAppInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteAppInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteAppInstallationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteAppSigningSecretRequest handles deleteAppSigningSecret operation.
//
// Delete an app signing secret.
//
// DELETE /organizations/{organization_id}/app_definitions/{app_definition_id}/signing_secret
func (s *Server) handleDeleteAppSigningSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteAppSigningSecretOperation,
			ID:   "deleteAppSigningSecret",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteAppSigningSecretOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteAppSigningSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteAppSigningSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteAppSigningSecretOperation,
			OperationSummary: "Delete an app signing secret",
			OperationID:      "deleteAppSigningSecret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteAppSigningSecretParams
			Response = DeleteAppSigningSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteAppSigningSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteAppSigningSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteAppSigningSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteAppSigningSecretResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteContentTypeRequest handles deleteContentType operation.
//
// Delete a content type.
//
// DELETE /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}
func (s *Server) handleDeleteContentTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteContentTypeOperation,
			ID:   "deleteContentType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteContentTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteContentTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteContentTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteContentTypeOperation,
			OperationSummary: "Delete a content type",
			OperationID:      "deleteContentType",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteContentTypeParams
			Response = DeleteContentTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteContentTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteContentType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteContentType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteContentTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteDeliveryApiKeyRequest handles deleteDeliveryApiKey operation.
//
// Delete a single delivery api key.
//
// DELETE /spaces/{space_id}/api_keys/{api_key_id}
func (s *Server) handleDeleteDeliveryApiKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteDeliveryApiKeyOperation,
			ID:   "deleteDeliveryApiKey",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteDeliveryApiKeyOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteDeliveryApiKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteDeliveryApiKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteDeliveryApiKeyOperation,
			OperationSummary: "Delete a single delivery api key",
			OperationID:      "deleteDeliveryApiKey",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "api_key_id",
					In:   "path",
				}: params.APIKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteDeliveryApiKeyParams
			Response = DeleteDeliveryApiKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteDeliveryApiKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteDeliveryApiKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteDeliveryApiKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteDeliveryApiKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteExtensionRequest handles deleteExtension operation.
//
// Delete an extension.
//
// DELETE /spaces/{space_id}/environments/{environment_id}/extensions/{extension_id}
func (s *Server) handleDeleteExtensionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteExtensionOperation,
			ID:   "deleteExtension",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteExtensionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteExtensionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteExtensionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteExtensionOperation,
			OperationSummary: "Delete an extension",
			OperationID:      "deleteExtension",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "extension_id",
					In:   "path",
				}: params.ExtensionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteExtensionParams
			Response = DeleteExtensionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteExtensionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteExtension(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteExtension(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteExtensionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteResourceProviderRequest handles deleteResourceProvider operation.
//
// Delete a resource provider definition.
//
// DELETE /organizations/{organization_id}/app_definitions/{app_definition_id}/resource_provider
func (s *Server) handleDeleteResourceProviderRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteResourceProviderOperation,
			ID:   "deleteResourceProvider",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteResourceProviderOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteResourceProviderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteResourceProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteResourceProviderOperation,
			OperationSummary: "Delete a resource provider definition",
			OperationID:      "deleteResourceProvider",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteResourceProviderParams
			Response = DeleteResourceProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteResourceProviderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteResourceProvider(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteResourceProvider(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteResourceProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteResourceTypeRequest handles deleteResourceType operation.
//
// Delete a resource type definition.
//
// DELETE /organizations/{organization_id}/app_definitions/{app_definition_id}/resource_provider/resource_types/{resource_type_id}
func (s *Server) handleDeleteResourceTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteResourceTypeOperation,
			ID:   "deleteResourceType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteResourceTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteResourceTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteResourceTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteResourceTypeOperation,
			OperationSummary: "Delete a resource type definition",
			OperationID:      "deleteResourceType",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
				{
					Name: "resource_type_id",
					In:   "path",
				}: params.ResourceTypeID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteResourceTypeParams
			Response = DeleteResourceTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteResourceTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteResourceType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteResourceType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteResourceTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteRoleRequest handles deleteRole operation.
//
// Delete a role.
//
// DELETE /spaces/{space_id}/roles/{role_id}
func (s *Server) handleDeleteRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteRoleOperation,
			ID:   "deleteRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteRoleOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteRoleOperation,
			OperationSummary: "Delete a role",
			OperationID:      "deleteRole",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "role_id",
					In:   "path",
				}: params.RoleID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteRoleParams
			Response = DeleteRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteRoleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteWebhookDefinitionRequest handles deleteWebhookDefinition operation.
//
// Delete a webhook definition.
//
// DELETE /spaces/{space_id}/webhook_definitions/{webhook_definition_id}
func (s *Server) handleDeleteWebhookDefinitionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteWebhookDefinitionOperation,
			ID:   "deleteWebhookDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, DeleteWebhookDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteWebhookDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response DeleteWebhookDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteWebhookDefinitionOperation,
			OperationSummary: "Delete a webhook definition",
			OperationID:      "deleteWebhookDefinition",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "webhook_definition_id",
					In:   "path",
				}: params.WebhookDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteWebhookDefinitionParams
			Response = DeleteWebhookDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteWebhookDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteWebhookDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteWebhookDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteWebhookDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAppDefinitionRequest handles getAppDefinition operation.
//
// Get one app definition.
//
// GET /organizations/{organization_id}/app_definitions/{app_definition_id}
func (s *Server) handleGetAppDefinitionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetAppDefinitionOperation,
			ID:   "getAppDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetAppDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetAppDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetAppDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetAppDefinitionOperation,
			OperationSummary: "Get one app definition",
			OperationID:      "getAppDefinition",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAppDefinitionParams
			Response = GetAppDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAppDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAppDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAppDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAppInstallationRequest handles getAppInstallation operation.
//
// Get one app installation.
//
// GET /spaces/{space_id}/environments/{environment_id}/app_installations/{app_definition_id}
func (s *Server) handleGetAppInstallationRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetAppInstallationOperation,
			ID:   "getAppInstallation",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetAppInstallationOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetAppInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetAppInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetAppInstallationOperation,
			OperationSummary: "Get one app installation",
			OperationID:      "getAppInstallation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAppInstallationParams
			Response = GetAppInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAppInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAppInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAppInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppInstallationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAppSigningSecretRequest handles getAppSigningSecret operation.
//
// Get one app signing secret.
//
// GET /organizations/{organization_id}/app_definitions/{app_definition_id}/signing_secret
func (s *Server) handleGetAppSigningSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetAppSigningSecretOperation,
			ID:   "getAppSigningSecret",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetAppSigningSecretOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetAppSigningSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetAppSigningSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetAppSigningSecretOperation,
			OperationSummary: "Get one app signing secret",
			OperationID:      "getAppSigningSecret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetAppSigningSecretParams
			Response = GetAppSigningSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetAppSigningSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAppSigningSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAppSigningSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAppSigningSecretResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAuthenticatedUserRequest handles getAuthenticatedUser operation.
//
// Get the authenticated user.
//
// GET /users/me
func (s *Server) handleGetAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetAuthenticatedUserOperation,
			ID:   "getAuthenticatedUser",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetAuthenticatedUserOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var rawBody []byte

	var response GetAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetAuthenticatedUserOperation,
			OperationSummary: "Get the authenticated user",
			OperationID:      "getAuthenticatedUser",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GetAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAuthenticatedUser(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAuthenticatedUser(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetAuthenticatedUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetContentTypeRequest handles getContentType operation.
//
// Get a content type.
//
// GET /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}
func (s *Server) handleGetContentTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetContentTypeOperation,
			ID:   "getContentType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetContentTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetContentTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetContentTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetContentTypeOperation,
			OperationSummary: "Get a content type",
			OperationID:      "getContentType",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetContentTypeParams
			Response = GetContentTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetContentTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetContentType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetContentType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetContentTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetDeliveryApiKeyRequest handles getDeliveryApiKey operation.
//
// Get a single delivery api key.
//
// GET /spaces/{space_id}/api_keys/{api_key_id}
func (s *Server) handleGetDeliveryApiKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetDeliveryApiKeyOperation,
			ID:   "getDeliveryApiKey",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetDeliveryApiKeyOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetDeliveryApiKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetDeliveryApiKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetDeliveryApiKeyOperation,
			OperationSummary: "Get a single delivery api key",
			OperationID:      "getDeliveryApiKey",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "api_key_id",
					In:   "path",
				}: params.APIKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetDeliveryApiKeyParams
			Response = GetDeliveryApiKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetDeliveryApiKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetDeliveryApiKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetDeliveryApiKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetDeliveryApiKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEditorInterfaceRequest handles getEditorInterface operation.
//
// Get the editor interface for a content type.
//
// GET /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}/editor_interface
func (s *Server) handleGetEditorInterfaceRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetEditorInterfaceOperation,
			ID:   "getEditorInterface",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetEditorInterfaceOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetEditorInterfaceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetEditorInterfaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetEditorInterfaceOperation,
			OperationSummary: "Get the editor interface for a content type",
			OperationID:      "getEditorInterface",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEditorInterfaceParams
			Response = GetEditorInterfaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEditorInterfaceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEditorInterface(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEditorInterface(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEditorInterfaceResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetExtensionRequest handles getExtension operation.
//
// Get a single extension.
//
// GET /spaces/{space_id}/environments/{environment_id}/extensions/{extension_id}
func (s *Server) handleGetExtensionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetExtensionOperation,
			ID:   "getExtension",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetExtensionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetExtensionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetExtensionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetExtensionOperation,
			OperationSummary: "Get a single extension",
			OperationID:      "getExtension",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "extension_id",
					In:   "path",
				}: params.ExtensionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetExtensionParams
			Response = GetExtensionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetExtensionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetExtension(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetExtension(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetExtensionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetMarketplaceAppDefinitionsRequest handles getMarketplaceAppDefinitions operation.
//
// Get marketplace app definitions.
//
// GET /app_definitions
func (s *Server) handleGetMarketplaceAppDefinitionsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetMarketplaceAppDefinitionsOperation,
			ID:   "getMarketplaceAppDefinitions",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetMarketplaceAppDefinitionsOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetMarketplaceAppDefinitionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetMarketplaceAppDefinitionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetMarketplaceAppDefinitionsOperation,
			OperationSummary: "Get marketplace app definitions",
			OperationID:      "getMarketplaceAppDefinitions",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "sys.id[in]",
					In:   "query",
				}: params.SysIDIn,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetMarketplaceAppDefinitionsParams
			Response = GetMarketplaceAppDefinitionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetMarketplaceAppDefinitionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetMarketplaceAppDefinitions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetMarketplaceAppDefinitions(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetMarketplaceAppDefinitionsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPersonalAccessTokenRequest handles getPersonalAccessToken operation.
//
// Get a single personal access token.
//
// GET /users/me/access_tokens/{access_token_id}
func (s *Server) handleGetPersonalAccessTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetPersonalAccessTokenOperation,
			ID:   "getPersonalAccessToken",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetPersonalAccessTokenOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetPersonalAccessTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetPersonalAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetPersonalAccessTokenOperation,
			OperationSummary: "Get a single personal access token",
			OperationID:      "getPersonalAccessToken",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "access_token_id",
					In:   "path",
				}: params.AccessTokenID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPersonalAccessTokenParams
			Response = GetPersonalAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPersonalAccessTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPersonalAccessToken(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPersonalAccessToken(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPersonalAccessTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetPreviewApiKeyRequest handles getPreviewApiKey operation.
//
// Get a single preview api key.
//
// GET /spaces/{space_id}/preview_api_keys/{preview_api_key_id}
func (s *Server) handleGetPreviewApiKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetPreviewApiKeyOperation,
			ID:   "getPreviewApiKey",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetPreviewApiKeyOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetPreviewApiKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetPreviewApiKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetPreviewApiKeyOperation,
			OperationSummary: "Get a single preview api key",
			OperationID:      "getPreviewApiKey",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "preview_api_key_id",
					In:   "path",
				}: params.PreviewAPIKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetPreviewApiKeyParams
			Response = GetPreviewApiKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetPreviewApiKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetPreviewApiKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetPreviewApiKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetPreviewApiKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourceProviderRequest handles getResourceProvider operation.
//
// Get one resource provider definition.
//
// GET /organizations/{organization_id}/app_definitions/{app_definition_id}/resource_provider
func (s *Server) handleGetResourceProviderRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetResourceProviderOperation,
			ID:   "getResourceProvider",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetResourceProviderOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetResourceProviderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetResourceProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetResourceProviderOperation,
			OperationSummary: "Get one resource provider definition",
			OperationID:      "getResourceProvider",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResourceProviderParams
			Response = GetResourceProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResourceProviderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourceProvider(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourceProvider(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourceProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetResourceTypeRequest handles getResourceType operation.
//
// Get one resource type definition.
//
// GET /organizations/{organization_id}/app_definitions/{app_definition_id}/resource_provider/resource_types/{resource_type_id}
func (s *Server) handleGetResourceTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetResourceTypeOperation,
			ID:   "getResourceType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetResourceTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetResourceTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetResourceTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetResourceTypeOperation,
			OperationSummary: "Get one resource type definition",
			OperationID:      "getResourceType",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
				{
					Name: "resource_type_id",
					In:   "path",
				}: params.ResourceTypeID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetResourceTypeParams
			Response = GetResourceTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetResourceTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetResourceType(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetResourceType(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetResourceTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRoleRequest handles getRole operation.
//
// Get a role.
//
// GET /spaces/{space_id}/roles/{role_id}
func (s *Server) handleGetRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetRoleOperation,
			ID:   "getRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetRoleOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetRoleOperation,
			OperationSummary: "Get a role",
			OperationID:      "getRole",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "role_id",
					In:   "path",
				}: params.RoleID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRoleParams
			Response = GetRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRole(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRole(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRoleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetSpaceEnablementsRequest handles getSpaceEnablements operation.
//
// Get enablements for a space.
//
// GET /spaces/{space_id}/enablements
func (s *Server) handleGetSpaceEnablementsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetSpaceEnablementsOperation,
			ID:   "getSpaceEnablements",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetSpaceEnablementsOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetSpaceEnablementsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetSpaceEnablementsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetSpaceEnablementsOperation,
			OperationSummary: "Get enablements for a space",
			OperationID:      "getSpaceEnablements",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetSpaceEnablementsParams
			Response = GetSpaceEnablementsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetSpaceEnablementsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetSpaceEnablements(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetSpaceEnablements(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetSpaceEnablementsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebhookDefinitionRequest handles getWebhookDefinition operation.
//
// Get a webhook definition.
//
// GET /spaces/{space_id}/webhook_definitions/{webhook_definition_id}
func (s *Server) handleGetWebhookDefinitionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetWebhookDefinitionOperation,
			ID:   "getWebhookDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, GetWebhookDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebhookDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GetWebhookDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetWebhookDefinitionOperation,
			OperationSummary: "Get a webhook definition",
			OperationID:      "getWebhookDefinition",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "webhook_definition_id",
					In:   "path",
				}: params.WebhookDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebhookDefinitionParams
			Response = GetWebhookDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebhookDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebhookDefinition(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebhookDefinition(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebhookDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutAppDefinitionRequest handles putAppDefinition operation.
//
// Create or update an app definition.
//
// PUT /organizations/{organization_id}/app_definitions/{app_definition_id}
func (s *Server) handlePutAppDefinitionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutAppDefinitionOperation,
			ID:   "putAppDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutAppDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutAppDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutAppDefinitionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutAppDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutAppDefinitionOperation,
			OperationSummary: "Create or update an app definition",
			OperationID:      "putAppDefinition",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = *AppDefinitionFields
			Params   = PutAppDefinitionParams
			Response = PutAppDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutAppDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutAppDefinition(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutAppDefinition(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutAppDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutAppInstallationRequest handles putAppInstallation operation.
//
// Install or update an app.
//
// PUT /spaces/{space_id}/environments/{environment_id}/app_installations/{app_definition_id}
func (s *Server) handlePutAppInstallationRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutAppInstallationOperation,
			ID:   "putAppInstallation",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutAppInstallationOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutAppInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutAppInstallationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutAppInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutAppInstallationOperation,
			OperationSummary: "Install or update an app",
			OperationID:      "putAppInstallation",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
				{
					Name: "X-Contentful-Marketplace",
					In:   "header",
				}: params.XContentfulMarketplace,
			},
			Raw: r,
		}

		type (
			Request  = *AppInstallationFields
			Params   = PutAppInstallationParams
			Response = PutAppInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutAppInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutAppInstallation(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutAppInstallation(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutAppInstallationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutAppSigningSecretRequest handles putAppSigningSecret operation.
//
// Create or update an app signing secret.
//
// PUT /organizations/{organization_id}/app_definitions/{app_definition_id}/signing_secret
func (s *Server) handlePutAppSigningSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutAppSigningSecretOperation,
			ID:   "putAppSigningSecret",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutAppSigningSecretOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutAppSigningSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutAppSigningSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutAppSigningSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutAppSigningSecretOperation,
			OperationSummary: "Create or update an app signing secret",
			OperationID:      "putAppSigningSecret",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = *AppSigningSecretRequestFields
			Params   = PutAppSigningSecretParams
			Response = PutAppSigningSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutAppSigningSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutAppSigningSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutAppSigningSecret(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutAppSigningSecretResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutContentTypeRequest handles putContentType operation.
//
// Update a content type.
//
// PUT /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}
func (s *Server) handlePutContentTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutContentTypeOperation,
			ID:   "putContentType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutContentTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutContentTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutContentTypeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutContentTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutContentTypeOperation,
			OperationSummary: "Update a content type",
			OperationID:      "putContentType",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *ContentTypeRequestFields
			Params   = PutContentTypeParams
			Response = PutContentTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutContentTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutContentType(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutContentType(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutContentTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutEditorInterfaceRequest handles putEditorInterface operation.
//
// Update the editor interface for a content type.
//
// PUT /spaces/{space_id}/environments/{environment_id}/content_types/{content_type_id}/editor_interface
func (s *Server) handlePutEditorInterfaceRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutEditorInterfaceOperation,
			ID:   "putEditorInterface",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutEditorInterfaceOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutEditorInterfaceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutEditorInterfaceRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutEditorInterfaceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutEditorInterfaceOperation,
			OperationSummary: "Update the editor interface for a content type",
			OperationID:      "putEditorInterface",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "content_type_id",
					In:   "path",
				}: params.ContentTypeID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *EditorInterfaceFields
			Params   = PutEditorInterfaceParams
			Response = PutEditorInterfaceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutEditorInterfaceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutEditorInterface(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutEditorInterface(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutEditorInterfaceResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutExtensionRequest handles putExtension operation.
//
// Create or update an extension.
//
// PUT /spaces/{space_id}/environments/{environment_id}/extensions/{extension_id}
func (s *Server) handlePutExtensionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutExtensionOperation,
			ID:   "putExtension",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutExtensionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutExtensionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutExtensionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutExtensionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutExtensionOperation,
			OperationSummary: "Create or update an extension",
			OperationID:      "putExtension",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "environment_id",
					In:   "path",
				}: params.EnvironmentID,
				{
					Name: "extension_id",
					In:   "path",
				}: params.ExtensionID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *ExtensionFields
			Params   = PutExtensionParams
			Response = PutExtensionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutExtensionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutExtension(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutExtension(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutExtensionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutResourceProviderRequest handles putResourceProvider operation.
//
// Create or update a resource provider definition.
//
// PUT /organizations/{organization_id}/app_definitions/{app_definition_id}/resource_provider
func (s *Server) handlePutResourceProviderRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutResourceProviderOperation,
			ID:   "putResourceProvider",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutResourceProviderOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutResourceProviderParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutResourceProviderRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutResourceProviderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutResourceProviderOperation,
			OperationSummary: "Create or update a resource provider definition",
			OperationID:      "putResourceProvider",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
			},
			Raw: r,
		}

		type (
			Request  = *ResourceProviderRequest
			Params   = PutResourceProviderParams
			Response = PutResourceProviderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutResourceProviderParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutResourceProvider(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutResourceProvider(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutResourceProviderResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutResourceTypeRequest handles putResourceType operation.
//
// Create or update a resource type definition.
//
// PUT /organizations/{organization_id}/app_definitions/{app_definition_id}/resource_provider/resource_types/{resource_type_id}
func (s *Server) handlePutResourceTypeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutResourceTypeOperation,
			ID:   "putResourceType",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutResourceTypeOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutResourceTypeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutResourceTypeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutResourceTypeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutResourceTypeOperation,
			OperationSummary: "Create or update a resource type definition",
			OperationID:      "putResourceType",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "organization_id",
					In:   "path",
				}: params.OrganizationID,
				{
					Name: "app_definition_id",
					In:   "path",
				}: params.AppDefinitionID,
				{
					Name: "resource_type_id",
					In:   "path",
				}: params.ResourceTypeID,
			},
			Raw: r,
		}

		type (
			Request  = *ResourceTypeFields
			Params   = PutResourceTypeParams
			Response = PutResourceTypeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutResourceTypeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutResourceType(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutResourceType(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutResourceTypeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutSpaceEnablementsRequest handles putSpaceEnablements operation.
//
// Update enablements for a space.
//
// PUT /spaces/{space_id}/enablements
func (s *Server) handlePutSpaceEnablementsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PutSpaceEnablementsOperation,
			ID:   "putSpaceEnablements",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, PutSpaceEnablementsOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutSpaceEnablementsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePutSpaceEnablementsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutSpaceEnablementsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PutSpaceEnablementsOperation,
			OperationSummary: "Update enablements for a space",
			OperationID:      "putSpaceEnablements",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *SpaceEnablementFields
			Params   = PutSpaceEnablementsParams
			Response = PutSpaceEnablementsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutSpaceEnablementsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutSpaceEnablements(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutSpaceEnablements(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutSpaceEnablementsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRevokePersonalAccessTokenRequest handles revokePersonalAccessToken operation.
//
// Revoke a personal access token.
//
// PUT /users/me/access_tokens/{access_token_id}/revoked
func (s *Server) handleRevokePersonalAccessTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: RevokePersonalAccessTokenOperation,
			ID:   "revokePersonalAccessToken",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, RevokePersonalAccessTokenOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeRevokePersonalAccessTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response RevokePersonalAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    RevokePersonalAccessTokenOperation,
			OperationSummary: "Revoke a personal access token",
			OperationID:      "revokePersonalAccessToken",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "access_token_id",
					In:   "path",
				}: params.AccessTokenID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = RevokePersonalAccessTokenParams
			Response = RevokePersonalAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackRevokePersonalAccessTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RevokePersonalAccessToken(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.RevokePersonalAccessToken(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRevokePersonalAccessTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateDeliveryApiKeyRequest handles updateDeliveryApiKey operation.
//
// Update a single delivery api key.
//
// PUT /spaces/{space_id}/api_keys/{api_key_id}
func (s *Server) handleUpdateDeliveryApiKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateDeliveryApiKeyOperation,
			ID:   "updateDeliveryApiKey",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, UpdateDeliveryApiKeyOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeUpdateDeliveryApiKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeUpdateDeliveryApiKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateDeliveryApiKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateDeliveryApiKeyOperation,
			OperationSummary: "Update a single delivery api key",
			OperationID:      "updateDeliveryApiKey",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "api_key_id",
					In:   "path",
				}: params.APIKeyID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *ApiKeyRequestFields
			Params   = UpdateDeliveryApiKeyParams
			Response = UpdateDeliveryApiKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateDeliveryApiKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateDeliveryApiKey(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateDeliveryApiKey(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateDeliveryApiKeyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateRoleRequest handles updateRole operation.
//
// Update a role.
//
// PUT /spaces/{space_id}/roles/{role_id}
func (s *Server) handleUpdateRoleRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateRoleOperation,
			ID:   "updateRole",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, UpdateRoleOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeUpdateRoleParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeUpdateRoleRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateRoleRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateRoleOperation,
			OperationSummary: "Update a role",
			OperationID:      "updateRole",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "role_id",
					In:   "path",
				}: params.RoleID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *RoleFields
			Params   = UpdateRoleParams
			Response = UpdateRoleRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateRoleParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateRole(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateRole(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateRoleResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateWebhookDefinitionRequest handles updateWebhookDefinition operation.
//
// Update a webhook definition.
//
// PUT /spaces/{space_id}/webhook_definitions/{webhook_definition_id}
func (s *Server) handleUpdateWebhookDefinitionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateWebhookDefinitionOperation,
			ID:   "updateWebhookDefinition",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityAccessToken(ctx, UpdateWebhookDefinitionOperation, r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "AccessToken",
					Err:              err,
				}
				defer recordError("Security:AccessToken", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeUpdateWebhookDefinitionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeUpdateWebhookDefinitionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UpdateWebhookDefinitionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateWebhookDefinitionOperation,
			OperationSummary: "Update a webhook definition",
			OperationID:      "updateWebhookDefinition",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "space_id",
					In:   "path",
				}: params.SpaceID,
				{
					Name: "webhook_definition_id",
					In:   "path",
				}: params.WebhookDefinitionID,
				{
					Name: "X-Contentful-Version",
					In:   "header",
				}: params.XContentfulVersion,
			},
			Raw: r,
		}

		type (
			Request  = *WebhookDefinitionFields
			Params   = UpdateWebhookDefinitionParams
			Response = UpdateWebhookDefinitionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateWebhookDefinitionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateWebhookDefinition(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateWebhookDefinition(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUpdateWebhookDefinitionResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
